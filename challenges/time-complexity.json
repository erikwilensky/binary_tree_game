[
  {
    "id": "linear_search",
    "title": "Linear Search",
    "code": "def linear_search(arr, target):\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1",
    "correct_answer": "O(n)",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
    "difficulty": "easy",
    "topic": "searching"
  },
  {
    "id": "binary_search",
    "title": "Binary Search",
    "code": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
    "correct_answer": "O(log n)",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
    "difficulty": "medium",
    "topic": "searching"
  },
  {
    "id": "bubble_sort",
    "title": "Bubble Sort",
    "code": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]",
    "correct_answer": "O(n²)",
    "options": ["O(n)", "O(n log n)", "O(n²)", "O(2ⁿ)"],
    "difficulty": "easy",
    "topic": "sorting"
  },
  {
    "id": "merge_sort",
    "title": "Merge Sort",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)",
    "correct_answer": "O(n log n)",
    "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
    "difficulty": "medium",
    "topic": "sorting"
  },
  {
    "id": "quick_sort",
    "title": "Quick Sort (Average Case)",
    "code": "def quick_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quick_sort(left) + middle + quick_sort(right)",
    "correct_answer": "O(n log n)",
    "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
    "difficulty": "medium",
    "topic": "sorting"
  },
  {
    "id": "quick_sort_worst",
    "title": "Quick Sort (Worst Case)",
    "code": "def quick_sort_worst(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[0]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quick_sort_worst(left) + middle + quick_sort_worst(right)",
    "correct_answer": "O(n²)",
    "options": ["O(n)", "O(n log n)", "O(n²)", "O(2ⁿ)"],
    "difficulty": "hard",
    "topic": "sorting"
  },
  {
    "id": "selection_sort",
    "title": "Selection Sort",
    "code": "def selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]",
    "correct_answer": "O(n²)",
    "options": ["O(n)", "O(n log n)", "O(n²)", "O(n³)"],
    "difficulty": "easy",
    "topic": "sorting"
  },
  {
    "id": "insertion_sort",
    "title": "Insertion Sort",
    "code": "def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key",
    "correct_answer": "O(n²)",
    "options": ["O(n)", "O(n log n)", "O(n²)", "O(2ⁿ)"],
    "difficulty": "easy",
    "topic": "sorting"
  },
  {
    "id": "heap_sort",
    "title": "Heap Sort",
    "code": "def heap_sort(arr):\n    n = len(arr)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    for i in range(n - 1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]\n        heapify(arr, i, 0)",
    "correct_answer": "O(n log n)",
    "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
    "difficulty": "hard",
    "topic": "sorting"
  },
  {
    "id": "array_access",
    "title": "Array Element Access",
    "code": "def get_element(arr, index):\n    return arr[index]",
    "correct_answer": "O(1)",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
    "difficulty": "easy",
    "topic": "arrays"
  },
  {
    "id": "array_sum",
    "title": "Sum Array Elements",
    "code": "def sum_array(arr):\n    total = 0\n    for num in arr:\n        total += num\n    return total",
    "correct_answer": "O(n)",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
    "difficulty": "easy",
    "topic": "arrays"
  },
  {
    "id": "nested_loops",
    "title": "Nested Loops",
    "code": "def nested_operation(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(n):\n            print(arr[i], arr[j])",
    "correct_answer": "O(n²)",
    "options": ["O(n)", "O(n log n)", "O(n²)", "O(2ⁿ)"],
    "difficulty": "medium",
    "topic": "loops"
  },
  {
    "id": "triple_nested",
    "title": "Triple Nested Loops",
    "code": "def triple_nested(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                print(arr[i], arr[j], arr[k])",
    "correct_answer": "O(n³)",
    "options": ["O(n²)", "O(n³)", "O(n log n)", "O(2ⁿ)"],
    "difficulty": "medium",
    "topic": "loops"
  },
  {
    "id": "fibonacci_iterative",
    "title": "Fibonacci (Iterative)",
    "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    a, b = 0, 1\n    for i in range(2, n + 1):\n        a, b = b, a + b\n    return b",
    "correct_answer": "O(n)",
    "options": ["O(1)", "O(n)", "O(2ⁿ)", "O(log n)"],
    "difficulty": "medium",
    "topic": "dynamic_programming"
  },
  {
    "id": "fibonacci_recursive",
    "title": "Fibonacci (Recursive)",
    "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)",
    "correct_answer": "O(2ⁿ)",
    "options": ["O(n)", "O(n log n)", "O(2ⁿ)", "O(log n)"],
    "difficulty": "hard",
    "topic": "recursion"
  },
  {
    "id": "factorial",
    "title": "Factorial",
    "code": "def factorial(n):\n    if n <= 1:\n        return 1\n    return n * factorial(n - 1)",
    "correct_answer": "O(n)",
    "options": ["O(1)", "O(n)", "O(n²)", "O(2ⁿ)"],
    "difficulty": "easy",
    "topic": "recursion"
  },
  {
    "id": "power_naive",
    "title": "Power (Naive)",
    "code": "def power(base, exp):\n    result = 1\n    for i in range(exp):\n        result *= base\n    return result",
    "correct_answer": "O(n)",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
    "difficulty": "easy",
    "topic": "math"
  },
  {
    "id": "power_efficient",
    "title": "Power (Efficient)",
    "code": "def power(base, exp):\n    if exp == 0:\n        return 1\n    if exp % 2 == 0:\n        return power(base * base, exp // 2)\n    else:\n        return base * power(base * base, exp // 2)",
    "correct_answer": "O(log n)",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
    "difficulty": "hard",
    "topic": "math"
  },
  {
    "id": "matrix_multiplication",
    "title": "Matrix Multiplication",
    "code": "def matrix_multiply(A, B):\n    n = len(A)\n    C = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                C[i][j] += A[i][k] * B[k][j]\n    return C",
    "correct_answer": "O(n³)",
    "options": ["O(n²)", "O(n³)", "O(n log n)", "O(2ⁿ)"],
    "difficulty": "medium",
    "topic": "matrices"
  },
  {
    "id": "matrix_transpose",
    "title": "Matrix Transpose",
    "code": "def transpose(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n    result = [[0] * n for _ in range(m)]\n    for i in range(n):\n        for j in range(m):\n            result[j][i] = matrix[i][j]\n    return result",
    "correct_answer": "O(n²)",
    "options": ["O(n)", "O(n²)", "O(n log n)", "O(n³)"],
    "difficulty": "medium",
    "topic": "matrices"
  },
  {
    "id": "find_max",
    "title": "Find Maximum",
    "code": "def find_max(arr):\n    max_val = arr[0]\n    for num in arr:\n        if num > max_val:\n            max_val = num\n    return max_val",
    "correct_answer": "O(n)",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
    "difficulty": "easy",
    "topic": "arrays"
  },
  {
    "id": "find_duplicates",
    "title": "Find Duplicates",
    "code": "def find_duplicates(arr):\n    seen = set()\n    duplicates = []\n    for num in arr:\n        if num in seen:\n            duplicates.append(num)\n        else:\n            seen.add(num)\n    return duplicates",
    "correct_answer": "O(n)",
    "options": ["O(n)", "O(n log n)", "O(n²)", "O(2ⁿ)"],
    "difficulty": "medium",
    "topic": "arrays"
  },
  {
    "id": "find_duplicates_naive",
    "title": "Find Duplicates (Naive)",
    "code": "def find_duplicates(arr):\n    duplicates = []\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] == arr[j]:\n                duplicates.append(arr[i])\n    return duplicates",
    "correct_answer": "O(n²)",
    "options": ["O(n)", "O(n log n)", "O(n²)", "O(n³)"],
    "difficulty": "medium",
    "topic": "arrays"
  },
  {
    "id": "reverse_array",
    "title": "Reverse Array",
    "code": "def reverse_array(arr):\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1",
    "correct_answer": "O(n)",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
    "difficulty": "easy",
    "topic": "arrays"
  },
  {
    "id": "count_occurrences",
    "title": "Count Occurrences",
    "code": "def count_occurrences(arr, target):\n    count = 0\n    for num in arr:\n        if num == target:\n            count += 1\n    return count",
    "correct_answer": "O(n)",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
    "difficulty": "easy",
    "topic": "arrays"
  },
  {
    "id": "two_sum_naive",
    "title": "Two Sum (Naive)",
    "code": "def two_sum(arr, target):\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] + arr[j] == target:\n                return [i, j]\n    return []",
    "correct_answer": "O(n²)",
    "options": ["O(n)", "O(n log n)", "O(n²)", "O(n³)"],
    "difficulty": "medium",
    "topic": "arrays"
  },
  {
    "id": "two_sum_hash",
    "title": "Two Sum (Hash Map)",
    "code": "def two_sum(arr, target):\n    seen = {}\n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",
    "correct_answer": "O(n)",
    "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
    "difficulty": "medium",
    "topic": "arrays"
  },
  {
    "id": "tree_traversal",
    "title": "Tree Traversal (In-Order)",
    "code": "def inorder_traversal(root):\n    if root:\n        inorder_traversal(root.left)\n        print(root.val)\n        inorder_traversal(root.right)",
    "correct_answer": "O(n)",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
    "difficulty": "medium",
    "topic": "trees"
  },
  {
    "id": "tree_height",
    "title": "Tree Height",
    "code": "def tree_height(root):\n    if not root:\n        return 0\n    return 1 + max(tree_height(root.left), tree_height(root.right))",
    "correct_answer": "O(n)",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
    "difficulty": "medium",
    "topic": "trees"
  },
  {
    "id": "graph_bfs",
    "title": "Breadth-First Search",
    "code": "def bfs(graph, start):\n    queue = [start]\n    visited = {start}\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)",
    "correct_answer": "O(V + E)",
    "options": ["O(V)", "O(E)", "O(V + E)", "O(V × E)"],
    "difficulty": "hard",
    "topic": "graphs"
  },
  {
    "id": "graph_dfs",
    "title": "Depth-First Search",
    "code": "def dfs(graph, node, visited):\n    visited.add(node)\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited)",
    "correct_answer": "O(V + E)",
    "options": ["O(V)", "O(E)", "O(V + E)", "O(V²)"],
    "difficulty": "hard",
    "topic": "graphs"
  },
  {
    "id": "string_concat",
    "title": "String Concatenation (Loop)",
    "code": "def concat_strings(strings):\n    result = \"\"\n    for s in strings:\n        result += s\n    return result",
    "correct_answer": "O(n²)",
    "options": ["O(n)", "O(n log n)", "O(n²)", "O(n³)"],
    "difficulty": "hard",
    "topic": "strings"
  },
  {
    "id": "string_join",
    "title": "String Join",
    "code": "def join_strings(strings):\n    return \"\".join(strings)",
    "correct_answer": "O(n)",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
    "difficulty": "medium",
    "topic": "strings"
  },
  {
    "id": "palindrome_check",
    "title": "Palindrome Check",
    "code": "def is_palindrome(s):\n    left = 0\n    right = len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    return True",
    "correct_answer": "O(n)",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
    "difficulty": "easy",
    "topic": "strings"
  },
  {
    "id": "substring_search",
    "title": "Substring Search (Naive)",
    "code": "def find_substring(text, pattern):\n    n, m = len(text), len(pattern)\n    for i in range(n - m + 1):\n        if text[i:i+m] == pattern:\n            return i\n    return -1",
    "correct_answer": "O(n × m)",
    "options": ["O(n)", "O(m)", "O(n × m)", "O(n + m)"],
    "difficulty": "medium",
    "topic": "strings"
  },
  {
    "id": "gcd_euclidean",
    "title": "GCD (Euclidean Algorithm)",
    "code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a",
    "correct_answer": "O(log min(a, b))",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
    "difficulty": "hard",
    "topic": "math"
  },
  {
    "id": "prime_check",
    "title": "Prime Check (Naive)",
    "code": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True",
    "correct_answer": "O(n)",
    "options": ["O(1)", "O(log n)", "O(n)", "O(√n)"],
    "difficulty": "medium",
    "topic": "math"
  },
  {
    "id": "prime_check_optimized",
    "title": "Prime Check (Optimized)",
    "code": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True",
    "correct_answer": "O(√n)",
    "options": ["O(1)", "O(log n)", "O(n)", "O(√n)"],
    "difficulty": "hard",
    "topic": "math"
  },
  {
    "id": "list_append",
    "title": "List Append",
    "code": "def append_items(items, new_items):\n    for item in new_items:\n        items.append(item)",
    "correct_answer": "O(n)",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
    "difficulty": "easy",
    "topic": "arrays"
  },
  {
    "id": "list_insert",
    "title": "List Insert at Beginning",
    "code": "def insert_at_beginning(items, new_item):\n    items.insert(0, new_item)",
    "correct_answer": "O(n)",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
    "difficulty": "medium",
    "topic": "arrays"
  },
  {
    "id": "hash_table_insert",
    "title": "Hash Table Insert",
    "code": "def hash_insert(table, key, value):\n    index = hash(key) % len(table)\n    table[index] = value",
    "correct_answer": "O(1)",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
    "difficulty": "medium",
    "topic": "hash_tables"
  },
  {
    "id": "hash_table_search",
    "title": "Hash Table Search",
    "code": "def hash_search(table, key):\n    index = hash(key) % len(table)\n    return table[index]",
    "correct_answer": "O(1)",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
    "difficulty": "medium",
    "topic": "hash_tables"
  }
]

